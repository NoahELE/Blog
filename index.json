[{"content":"In this blog I want to complain about some annoying stuff in Go. I\u0026rsquo;m not saying that Go is bad, in fact I love Go for its simplicity and ease of use. It\u0026rsquo;s just that there are some designs in Go that ruin the experience for me.\nUgly Error Handling I\u0026rsquo;ll put a disclaimer here that I\u0026rsquo;m not a fan of exceptions either. I think exceptions are a bad idea in general. But I think Go\u0026rsquo;s error handling is even worse. Go\u0026rsquo;s error handling actually encourage those who are lazy and punish those who want to write good code.\nCompare this\nfunc doSomething() (any, error) { res1, err := do1() if (err != nil) { return nil, err } res2, err := do2() if (err != nil) { return nil, err } res3, err := do3() if (err != nil) { return nil, err } return res1 + res2 + res3, nil } to\nfunc doSomething() (any, error) { res1, _ := do1() res2, _ := do2() res3, _ := do3() return res1 + res2 + res3, nil } If you want to write safe code you\u0026rsquo;ll have to write the boilerplate once and once again. And if you just write unsafe code, it\u0026rsquo;s way cleaner and more elegant, and there is nothing in the language that stops you from doing that.\nA good language design should make writing safe code easier and unsafe code harder. At least there should be a syntax sugar to simplify this, since 90% of the time you just want to return the error.\ndefer is not Block Scoped Instead of\nfunc doSomething() { { conn1 := connect1() defer close1(conn1) } { conn2 := connect1() defer close2(conn2) } { conn3 := connect3() defer close3(conn3) } } you have to write\nfunc doSomething() { func () { conn1 := connect1() defer close1(conn1) }() func () { conn2 := connect1() defer close2(conn2) }() func () { conn3 := connect3() defer close3(conn3) }() } I don\u0026rsquo;t know why Go doesn\u0026rsquo;t make defer block scoped. It\u0026rsquo;s just so much more convenient and intuitive.\nGo has block scoped variables, why not defer? It\u0026rsquo;s really silly to have to wrap everything in a lambda function just to use defer.\nNo Tuple Type Go doesn\u0026rsquo;t have tuple type. It make multiple return a feature but leaves tuple out of the language. I have no ideas why. The multiple return actually just returns a tuple, but you can\u0026rsquo;t receive the tuple as a whole or pass it around.\nfunc foo() (int, string) { return 1, \u0026#34;hello\u0026#34; } func bar(i int, s string) { fmt.Println(i, s) } func main() { bar(foo()) // valid!? } Why would this work? It\u0026rsquo;s just so inconsistent. If you can\u0026rsquo;t receive a tuple as a whole, why can you pass it as a whole? It\u0026rsquo;s just so weird.\nNo Runtime Const Go has no way to ensure immutability. If you declare a global map or slice, you have no guarantee that it won\u0026rsquo;t be modified.\nToo Strict Compiler I think it is common for programmers to comment out some code for debugging purpose. But if you comment out all the lines that use an import, Go will complain that the import is unused. You have to delete the import line to make it work. And when you uncomment the code, you have to add the import line back. It\u0026rsquo;s just so annoying. It is also the same case for unused variables.\nShouldn\u0026rsquo;t this be linter\u0026rsquo;s job? Why would the compiler care about this?\n","permalink":"https://noahele.github.io/Blog/posts/annoying-stuff-in-go/","summary":"In this blog I want to complain about some annoying stuff in Go. I\u0026rsquo;m not saying that Go is bad, in fact I love Go for its simplicity and ease of use. It\u0026rsquo;s just that there are some designs in Go that ruin the experience for me.\nUgly Error Handling I\u0026rsquo;ll put a disclaimer here that I\u0026rsquo;m not a fan of exceptions either. I think exceptions are a bad idea in general.","title":"Annoying Stuff in Go"},{"content":"Recently I\u0026rsquo;ve been playing with Elixir and found a interesting operator called Pipe, which is |\u0026gt;. Elixir makes use of it to pipe a function\u0026rsquo;s output to another function. It helps to write clean code like this:\n\u0026#34;hello world\u0026#34; |\u0026gt; String.upcase() |\u0026gt; String.split(\u0026#34; \u0026#34;) |\u0026gt; Enum.reverse() |\u0026gt; Enum.join(\u0026#34; \u0026#34;) # instead of Enum.join(Enum.reverse(String.split(String.upcase(\u0026#34;hello world\u0026#34;), \u0026#34; \u0026#34;)), \u0026#34; \u0026#34;) But then I found that pipeline operator is not so common in other languages I know like Java, JavaScript and Python. It took me some time to realize that its equivalent in OOP world is just chaining methods due to the implicit this parameter in object methods. For example, in JavaScript, we can write:\n\u0026#39;hello world\u0026#39;.toUpperCase().split(\u0026#39; \u0026#39;).reverse().join(\u0026#39; \u0026#39;); But in Python, the join method is on string instead of list type, so we have to write:\n# either tmp variable words = \u0026#39;hello world\u0026#39;.upper().split(\u0026#39; \u0026#39;).reverse() \u0026#39; \u0026#39;.join(words) # or brackets hell \u0026#39; \u0026#39;.join(\u0026#39;hello world\u0026#39;.upper().split(\u0026#39; \u0026#39;).reverse()) I do feel that Python has a bad design here. Though it has the full power of OOP, it move a lot of method to global level like len, enumerate, map, filter. It\u0026rsquo;s neither consistent nor elegant, making chaining methods, which are easy in other languages, somewhat hard in Python.\nIt also pollutes the global namespace. I think all Python developers have encountered the problem of naming a variable max and then find that the variable conflicts with max function, then rename the variable to max1, num_max or something else. It\u0026rsquo;s really annoying.\nA good language design that I love is Rust. Chaining methods is easy in Rust, and even max can be called in chaining style as well as function style. Due to its explicit self parameter, methods can be both instance methods and a normal function. So you can write:\nlet vec = vec![1, 2, 3]; // chaining enumerate() vec.iter().enumerate(); // chaining map() vec.iter().map(); // chaining len() vec.len(); // even max() can be called in chaining style let a = 1.max(2); // and you can still call it in function style let b = i32::max(1, 2); Python and JavaScript can also achieve similar effects. Python has a explicit self parameter, and JavaScript has call, apply and bind to change the implicit this. But they are not widely used. e.g.\nlst = [1, 2, 3] list.append(lst, 4) const arr = [1, 2, 3]; Array.prototype.push.call(arr, 4); ","permalink":"https://noahele.github.io/Blog/posts/thoughts-on-pipe-operator/","summary":"Recently I\u0026rsquo;ve been playing with Elixir and found a interesting operator called Pipe, which is |\u0026gt;. Elixir makes use of it to pipe a function\u0026rsquo;s output to another function. It helps to write clean code like this:\n\u0026#34;hello world\u0026#34; |\u0026gt; String.upcase() |\u0026gt; String.split(\u0026#34; \u0026#34;) |\u0026gt; Enum.reverse() |\u0026gt; Enum.join(\u0026#34; \u0026#34;) # instead of Enum.join(Enum.reverse(String.split(String.upcase(\u0026#34;hello world\u0026#34;), \u0026#34; \u0026#34;)), \u0026#34; \u0026#34;) But then I found that pipeline operator is not so common in other languages I know like Java, JavaScript and Python.","title":"Thoughts on Pipe Operator"},{"content":"","permalink":"https://noahele.github.io/Blog/posts/javascript-related/","summary":"","title":"Javascript Related"},{"content":"Java The reason why record classes have accessor methods instead of public final attributes: make it possible to override accessor methods allow the record class to implement interfaces Lombok @Data generates constructor only if there is no explicitly written constructor @Data should not be used on Hibernate entities, as the generated equals and hashCode methods will cause problems when the entity is detached from the session. Spring @Autowired can be used on constructor, setter and field. Constructor injection is recommended. My preference is constructor injection \u0026gt; setter injection \u0026gt; field injection. And then utilize @RequiredArgsConstructor lombok annotation to generate constructor with required fields. By marking all required beans private final, it is automatically present in the constructor generated and thus injected. I think this is a more elegant way of injecting dependencies. Circular references is discouraged and they are prohibited by default. Possible Solutions: Modify the code base to remove circular references Add @Lazy annotation to constructor, so that the bean is not created until it is needed Use setter injection instead of constructor injection ","permalink":"https://noahele.github.io/Blog/posts/java-related/","summary":"Java The reason why record classes have accessor methods instead of public final attributes: make it possible to override accessor methods allow the record class to implement interfaces Lombok @Data generates constructor only if there is no explicitly written constructor @Data should not be used on Hibernate entities, as the generated equals and hashCode methods will cause problems when the entity is detached from the session. Spring @Autowired can be used on constructor, setter and field.","title":"Java Related"},{"content":"Revise about many graph-searching related algorithms.\nDFS: Depth First Search Search till the leaf vertex then choose another path.\nIt will find a path between two vertices and it\u0026rsquo;s guaranteed to do so, however it is not guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed Uses a stack data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the stack while the vertex is not empty pop a vertex out of the stack if the vertex is: the destination, then end search marked visited, then continue unvisited: mark it as visited add its unvisited neighbors to the stack BFS: Breadth First Search Search all neighbors of a vertex then move on next level.\nIt is guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed cyclic Uses a queue data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the queue mark the vertex visited while the queue is not empty: pop a vertex from queue if the vertex is: the destination, then end search else: mark its unvisited neighbors as visited push said neighbors to the queue Uniform Cost Search an adaptation of breadth-first search to make it work on weighted graph\nworks on graphs that are:\nconnected weighted: no negative edges directed cyclic Dijkstra Algorithm This algorithm find the shortest path from a vertex to all other vertices\nUsing 2 data structures:\na priority queue of vertices lists of: shortest distance and preceding vertices in shortest path The steps of this algorithm are:\nSet up auxiliary data structures While the priority queue has unexplored vertices: Take the next vertex from the priority queue Follow its edges and update any distances Its time complexity depends on the data structures used.\nIf we are using a heap for the priority queue and two array, the time complexity is $$O((V + E)logV)$$\nThis algorithm works on graphs that are:\ndirected weighted: only guaranteed to be correct when there are no negative edges Floyd-Warshall Algorithm for (i = 1; i \u0026lt;= n; i++) { for (j = 1; j \u0026lt;= n; j++) { if (e[i][j] \u0026gt; e[i][1] + e[1][j]) { e[i][j] = e[i][1] + e[1][j]; } } } For every intermediate vertex check if there is a shorter path from start to end point through the intermediate.\n","permalink":"https://noahele.github.io/Blog/posts/graph-search-algorithms/","summary":"Revise about many graph-searching related algorithms.\nDFS: Depth First Search Search till the leaf vertex then choose another path.\nIt will find a path between two vertices and it\u0026rsquo;s guaranteed to do so, however it is not guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed Uses a stack data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the stack while the vertex is not empty pop a vertex out of the stack if the vertex is: the destination, then end search marked visited, then continue unvisited: mark it as visited add its unvisited neighbors to the stack BFS: Breadth First Search Search all neighbors of a vertex then move on next level.","title":"Graph Search Algorithms"}]