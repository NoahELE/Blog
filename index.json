[{"content":"Pipe Operator Recently I\u0026rsquo;ve been attracted by the pipe operator in Elixir, which is |\u0026gt;. It\u0026rsquo;s a very simple operator, but it can make the code more readable and easier to understand. It helps write clean code like this:\n\u0026#34;hello world\u0026#34; |\u0026gt; String.upcase() |\u0026gt; String.split(\u0026#34; \u0026#34;) |\u0026gt; Enum.reverse() |\u0026gt; Enum.join(\u0026#34; \u0026#34;) # instead of Enum.join(Enum.reverse(String.split(String.upcase(\u0026#34;hello world\u0026#34;), \u0026#34; \u0026#34;)), \u0026#34; \u0026#34;) But then I found that pipeline operator is not so common in other languages I know like Java, JavaScript and Python. It took me some time to realize that its equivalent in OOP world is just chaining methods due to the implicit this parameter in object methods. For example, in JavaScript, we can write:\n\u0026#39;hello world\u0026#39;.toUpperCase().split(\u0026#39; \u0026#39;).reverse().join(\u0026#39; \u0026#39;); But in Python, the join method is on string instead of list type, so we have to write:\nwords = \u0026#39;hello world\u0026#39;.upper().split(\u0026#39; \u0026#39;).reverse() \u0026#39; \u0026#39;.join(words) I do feel that Python has a bad design here. Though it has the full power of OOP, it move a lot of method to global level like len, enumerate, map, filter. It\u0026rsquo;s neither consistent nor elegant, making chaining methods, which are easy in other languages, somewhat hard in Python.\n","permalink":"https://noahele.github.io/Blog/posts/functional-programming/","summary":"Pipe Operator Recently I\u0026rsquo;ve been attracted by the pipe operator in Elixir, which is |\u0026gt;. It\u0026rsquo;s a very simple operator, but it can make the code more readable and easier to understand. It helps write clean code like this:\n\u0026#34;hello world\u0026#34; |\u0026gt; String.upcase() |\u0026gt; String.split(\u0026#34; \u0026#34;) |\u0026gt; Enum.reverse() |\u0026gt; Enum.join(\u0026#34; \u0026#34;) # instead of Enum.join(Enum.reverse(String.split(String.upcase(\u0026#34;hello world\u0026#34;), \u0026#34; \u0026#34;)), \u0026#34; \u0026#34;) But then I found that pipeline operator is not so common in other languages I know like Java, JavaScript and Python.","title":"Functional Programming"},{"content":"","permalink":"https://noahele.github.io/Blog/posts/javascript-related/","summary":"","title":"Javascript Related"},{"content":"Java The reason of record class has accessors instead of public final attributes: make it possible to override accessor methods allow the record class to implement interfaces Lombok @Data generates constructor only if there is no explicitly written constructor @Data is not recommended for Hibernate entities, as the generated equals and hashCode methods are not suitable for entities managed by Hibernate Spring Circular references is discouraged and they are prohibited by default. Possible Solutions: Modify the code base to remove circular references Add @Lazy annotation to constructor ","permalink":"https://noahele.github.io/Blog/posts/java-related/","summary":"Java The reason of record class has accessors instead of public final attributes: make it possible to override accessor methods allow the record class to implement interfaces Lombok @Data generates constructor only if there is no explicitly written constructor @Data is not recommended for Hibernate entities, as the generated equals and hashCode methods are not suitable for entities managed by Hibernate Spring Circular references is discouraged and they are prohibited by default.","title":"Java Related"},{"content":"Revise about many graph-searching related algorithms.\nDFS: Depth First Search Search till the leaf vertex then choose another path.\nIt will find a path between two vertices and it\u0026rsquo;s guaranteed to do so, however it is not guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed Uses a stack data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the stack while the vertex is not empty pop a vertex out of the stack if the vertex is: the destination, then end search marked visited, then continue unvisited: mark it as visited add its unvisited neighbors to the stack BFS: Breadth First Search Search all neighbors of a vertex then move on next level.\nIt is guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed cyclic Uses a queue data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the queue mark the vertex visited while the queue is not empty: pop a vertex from queue if the vertex is: the destination, then end search else: mark its unvisited neighbors as visited push said neighbors to the queue Uniform Cost Search an adaptation of breadth-first search to make it work on weighted graph\nworks on graphs that are:\nconnected weighted: no negative edges directed cyclic Dijkstra Algorithm This algorithm find the shortest path from a vertex to all other vertices\nUsing 2 data structures:\na priority queue of vertices lists of: shortest distance and preceding vertices in shortest path The steps of this algorithm are:\nSet up auxiliary data structures While the priority queue has unexplored vertices: Take the next vertex from the priority queue Follow its edges and update any distances Its time complexity depends on the data structures used.\nIf we are using a heap for the priority queue and two array, the time complexity is $$O((V + E)logV)$$\nThis algorithm works on graphs that are:\ndirected weighted: only guaranteed to be correct when there are no negative edges Floyd-Warshall Algorithm for (i = 1; i \u0026lt;= n; i++) { for (j = 1; j \u0026lt;= n; j++) { if (e[i][j] \u0026gt; e[i][1] + e[1][j]) { e[i][j] = e[i][1] + e[1][j]; } } } For every intermediate vertex check if there is a shorter path from start to end point through the intermediate.\n","permalink":"https://noahele.github.io/Blog/posts/graph-search-algorithms/","summary":"Revise about many graph-searching related algorithms.\nDFS: Depth First Search Search till the leaf vertex then choose another path.\nIt will find a path between two vertices and it\u0026rsquo;s guaranteed to do so, however it is not guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed Uses a stack data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the stack while the vertex is not empty pop a vertex out of the stack if the vertex is: the destination, then end search marked visited, then continue unvisited: mark it as visited add its unvisited neighbors to the stack BFS: Breadth First Search Search all neighbors of a vertex then move on next level.","title":"Graph Search Algorithms"}]