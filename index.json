[{"content":"","permalink":"https://noahele.github.io/Blog/posts/miscellaneous/","summary":"","title":"Miscellaneous"},{"content":"Revise about many graph-searching related algorithms.\nDFS: Depth First Search Search till the leaf vertex then choose another path.\nIt will find a path between two vertices and it\u0026rsquo;s guaranteed to do so, however it is not guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed Uses a stack data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the stack while the vertex is not empty pop a vertex out of the stack if the vertex is: the destination, then end search marked visited, then continue unvisited: mark it as visited add its unvisited neighbors to the stack BFS: Breadth First Search Search all neighbors of a vertex then move on next level.\nIt is guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed cyclic Uses a queue data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the queue mark the vertex visited while the queue is not empty: pop a vertex from queue if the vertex is: the destination, then end search else: mark its unvisited neighbors as visited push said neighbors to the queue Uniform Cost Search an adaptation of breadth-first search to make it work on weighted graph\nworks on graphs that are:\nconnected weighted: no negative edges directed cyclic Dijkstra Algorithm This algorithm find the shortest path from a vertex to all other vertices\nUsing 2 data structures:\na priority queue of vertices lists of: shortest distance and preceding vertices in shortest path The steps of this algorithm are:\nSet up auxiliary data structures While the priority queue has unexplored vertices: Take the next vertex from the priority queue Follow its edges and update any distances Its time complexity depends on the data structures used.\nIf we are using a heap for the priority queue and two array, the time complexity is $$O((V + E)logV)$$\nThis algorithm works on graphs that are:\ndirected weighted: only guaranteed to be correct when there are no negative edges Floyd-Warshall Algorithm for (i = 1; i \u0026lt;= n; i++) { for (j = 1; j \u0026lt;= n; j++) { if (e[i][j] \u0026gt; e[i][1] + e[1][j]) { e[i][j] = e[i][1] + e[1][j]; } } } For every intermediate vertex check if there is a shorter path from start to end point through the intermediate.\n","permalink":"https://noahele.github.io/Blog/posts/graph-search-algorithms/","summary":"Revise about many graph-searching related algorithms.\nDFS: Depth First Search Search till the leaf vertex then choose another path.\nIt will find a path between two vertices and it\u0026rsquo;s guaranteed to do so, however it is not guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed Uses a stack data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the stack while the vertex is not empty pop a vertex out of the stack if the vertex is: the destination, then end search marked visited, then continue unvisited: mark it as visited add its unvisited neighbors to the stack BFS: Breadth First Search Search all neighbors of a vertex then move on next level.","title":"Graph Search Algorithms"}]