[{"content":"Recently I\u0026rsquo;ve been playing with Elixir and found a interesting operator called Pipe, which is |\u0026gt;. Elixir makes use of it to pipe a function\u0026rsquo;s output to another function. It helps to write clean code like this:\n\u0026#34;hello world\u0026#34; |\u0026gt; String.upcase() |\u0026gt; String.split(\u0026#34; \u0026#34;) |\u0026gt; Enum.reverse() |\u0026gt; Enum.join(\u0026#34; \u0026#34;) # instead of Enum.join(Enum.reverse(String.split(String.upcase(\u0026#34;hello world\u0026#34;), \u0026#34; \u0026#34;)), \u0026#34; \u0026#34;) But then I found that pipeline operator is not so common in other languages I know like Java, JavaScript and Python. It took me some time to realize that its equivalent in OOP world is just chaining methods due to the implicit this parameter in object methods. For example, in JavaScript, we can write:\n\u0026#39;hello world\u0026#39;.toUpperCase().split(\u0026#39; \u0026#39;).reverse().join(\u0026#39; \u0026#39;); But in Python, the join method is on string instead of list type, so we have to write:\n# either tmp variable words = \u0026#39;hello world\u0026#39;.upper().split(\u0026#39; \u0026#39;).reverse() \u0026#39; \u0026#39;.join(words) # or brackets hell \u0026#39; \u0026#39;.join(\u0026#39;hello world\u0026#39;.upper().split(\u0026#39; \u0026#39;).reverse()) I do feel that Python has a bad design here. Though it has the full power of OOP, it move a lot of method to global level like len, enumerate, map, filter. It\u0026rsquo;s neither consistent nor elegant, making chaining methods, which are easy in other languages, somewhat hard in Python.\nIt also pollutes the global namespace. I think all Python developers have encountered the problem of naming a variable max and then find that the variable conflicts with max function, then rename the variable to max1, num_max or something else. It\u0026rsquo;s really annoying.\nA good language design that I love is Rust. Chaining methods is easy in Rust, and even max can be called in chaining style as well as function style. Due to its explicit self parameter, methods can be both instance methods and a normal function. So you can write:\nlet vec = vec![1, 2, 3]; // chaining enumerate() vec.iter().enumerate(); // chaining map() vec.iter().map(); // chaining len() vec.len(); // even max() can be called in chaining style let a = 1.max(2); // and you can still call it in function style let b = i32::max(1, 2); Python and JavaScript can also achieve similar effects. Python has a explicit self parameter, and JavaScript has call, apply and bind to change the implicit this. But they are not widely used. e.g.\nlst = [1, 2, 3] list.append(lst, 4) const arr = [1, 2, 3]; Array.prototype.push.call(arr, 4); ","permalink":"https://noahele.github.io/Blog/posts/thoughts-on-pipe-operator/","summary":"Recently I\u0026rsquo;ve been playing with Elixir and found a interesting operator called Pipe, which is |\u0026gt;. Elixir makes use of it to pipe a function\u0026rsquo;s output to another function. It helps to write clean code like this:\n\u0026#34;hello world\u0026#34; |\u0026gt; String.upcase() |\u0026gt; String.split(\u0026#34; \u0026#34;) |\u0026gt; Enum.reverse() |\u0026gt; Enum.join(\u0026#34; \u0026#34;) # instead of Enum.join(Enum.reverse(String.split(String.upcase(\u0026#34;hello world\u0026#34;), \u0026#34; \u0026#34;)), \u0026#34; \u0026#34;) But then I found that pipeline operator is not so common in other languages I know like Java, JavaScript and Python.","title":"Thoughts on Pipe Operator"},{"content":"","permalink":"https://noahele.github.io/Blog/posts/javascript-related/","summary":"","title":"Javascript Related"},{"content":"Java The reason why record classes have accessor methods instead of public final attributes: make it possible to override accessor methods allow the record class to implement interfaces Lombok @Data generates constructor only if there is no explicitly written constructor @Data should not be used on Hibernate entities, as the generated equals and hashCode methods will cause problems when the entity is detached from the session. Spring @Autowired can be used on constructor, setter and field. Constructor injection is recommended. My preference is constructor injection \u0026gt; setter injection \u0026gt; field injection. And then utilize @RequiredArgsConstructor lombok annotation to generate constructor with required fields. By marking all required beans private final, it is automatically present in the constructor generated and thus injected. I think this is a more elegant way of injecting dependencies. Circular references is discouraged and they are prohibited by default. Possible Solutions: Modify the code base to remove circular references Add @Lazy annotation to constructor, so that the bean is not created until it is needed Use setter injection instead of constructor injection ","permalink":"https://noahele.github.io/Blog/posts/java-related/","summary":"Java The reason why record classes have accessor methods instead of public final attributes: make it possible to override accessor methods allow the record class to implement interfaces Lombok @Data generates constructor only if there is no explicitly written constructor @Data should not be used on Hibernate entities, as the generated equals and hashCode methods will cause problems when the entity is detached from the session. Spring @Autowired can be used on constructor, setter and field.","title":"Java Related"},{"content":"Revise about many graph-searching related algorithms.\nDFS: Depth First Search Search till the leaf vertex then choose another path.\nIt will find a path between two vertices and it\u0026rsquo;s guaranteed to do so, however it is not guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed Uses a stack data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the stack while the vertex is not empty pop a vertex out of the stack if the vertex is: the destination, then end search marked visited, then continue unvisited: mark it as visited add its unvisited neighbors to the stack BFS: Breadth First Search Search all neighbors of a vertex then move on next level.\nIt is guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed cyclic Uses a queue data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the queue mark the vertex visited while the queue is not empty: pop a vertex from queue if the vertex is: the destination, then end search else: mark its unvisited neighbors as visited push said neighbors to the queue Uniform Cost Search an adaptation of breadth-first search to make it work on weighted graph\nworks on graphs that are:\nconnected weighted: no negative edges directed cyclic Dijkstra Algorithm This algorithm find the shortest path from a vertex to all other vertices\nUsing 2 data structures:\na priority queue of vertices lists of: shortest distance and preceding vertices in shortest path The steps of this algorithm are:\nSet up auxiliary data structures While the priority queue has unexplored vertices: Take the next vertex from the priority queue Follow its edges and update any distances Its time complexity depends on the data structures used.\nIf we are using a heap for the priority queue and two array, the time complexity is $$O((V + E)logV)$$\nThis algorithm works on graphs that are:\ndirected weighted: only guaranteed to be correct when there are no negative edges Floyd-Warshall Algorithm for (i = 1; i \u0026lt;= n; i++) { for (j = 1; j \u0026lt;= n; j++) { if (e[i][j] \u0026gt; e[i][1] + e[1][j]) { e[i][j] = e[i][1] + e[1][j]; } } } For every intermediate vertex check if there is a shorter path from start to end point through the intermediate.\n","permalink":"https://noahele.github.io/Blog/posts/graph-search-algorithms/","summary":"Revise about many graph-searching related algorithms.\nDFS: Depth First Search Search till the leaf vertex then choose another path.\nIt will find a path between two vertices and it\u0026rsquo;s guaranteed to do so, however it is not guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed Uses a stack data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the stack while the vertex is not empty pop a vertex out of the stack if the vertex is: the destination, then end search marked visited, then continue unvisited: mark it as visited add its unvisited neighbors to the stack BFS: Breadth First Search Search all neighbors of a vertex then move on next level.","title":"Graph Search Algorithms"}]