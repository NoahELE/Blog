[{"content":"Difference between declaring beans with @Bean in @Configuration class and @Component class.\n// @Configuration // @Component public class Foo { @Bean public Bar bar() { return new Bar(); } @Bean public Baz baz() { Bar bar1 = bar(); Bar bar2 = bar(); return new Baz(); } } For the above class, if the class is annotated with @Component, bar1 and bar2 will be 2 different instances. However, if the class is annotated with @Configuration, bar1 and bar2 will be the same instance. This is because spring creates proxy for @Configuration class which makes sure that the same instance is returned when the bean method is called.\n","permalink":"https://noahele.github.io/Blog/posts/bean-in-configuration-or-component/","summary":"\u003cp\u003eDifference between declaring beans with @Bean in @Configuration class and @Component class.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// @Configuration\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// @Component\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003e@Bean\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e Bar \u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Bar();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003e@Bean\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e Baz \u003cspan style=\"color:#a6e22e\"\u003ebaz\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Bar bar1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e bar();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Bar bar2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e bar();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Baz();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFor the above class, if the class is annotated with @Component, bar1 and bar2 will be 2 different instances. However, if the class is annotated with @Configuration, bar1 and bar2 will be the same instance. This is because spring creates proxy for @Configuration class which makes sure that the same instance is returned when the bean method is called.\u003c/p\u003e","title":"@Bean in @Configuration or @Component"},{"content":"Java\u0026rsquo;s Lambda Java\u0026rsquo;s Lambda is actually a syntax sugar for anonymous implementation for functional interfaces. For example, the 2 are equivalent:\npublic class Main { public static void main(String[] args) { Runnable f1 = () -\u0026gt; System.out.println(\u0026#34;lambda\u0026#34;); Runnable f2 = new Runnable() { public void run() { System.out.println(\u0026#34;lambda\u0026#34;); } } } } Note: the variables captured by the lambda must be final or effectively final.\n","permalink":"https://noahele.github.io/Blog/posts/java-lambda/","summary":"\u003ch2 id=\"javas-lambda\"\u003eJava\u0026rsquo;s Lambda\u003c/h2\u003e\n\u003cp\u003eJava\u0026rsquo;s Lambda is actually a syntax sugar for anonymous implementation for functional interfaces. For example, the 2 are equivalent:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-Java\" data-lang=\"Java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMain\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e(String\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e args) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Runnable f1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e () \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e System.\u003cspan style=\"color:#a6e22e\"\u003eout\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;lambda\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Runnable f2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Runnable() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003erun\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                System.\u003cspan style=\"color:#a6e22e\"\u003eout\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;lambda\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eNote: the variables captured by the lambda must be final or effectively final.\u003c/p\u003e\u003c/blockquote\u003e","title":"Java Lambda"},{"content":"In this blog I want to complain about some annoying stuff in Go. I\u0026rsquo;m not saying that Go is bad, in fact I love Go for its simplicity and ease of use. It\u0026rsquo;s just that there are some designs in Go that ruin the experience for me.\nUgly Error Handling I\u0026rsquo;ll put a disclaimer here that I\u0026rsquo;m not a fan of exceptions either. I think exceptions are a bad idea in general. But I think Go\u0026rsquo;s error handling is even worse. Go\u0026rsquo;s error handling actually encourage those who are lazy and punish those who want to write good code.\nCompare this\nfunc doSomething() (any, error) { res1, err := do1() if (err != nil) { return nil, err } res2, err := do2() if (err != nil) { return nil, err } res3, err := do3() if (err != nil) { return nil, err } return res1 + res2 + res3, nil } to\nfunc doSomething() (any, error) { res1, _ := do1() res2, _ := do2() res3, _ := do3() return res1 + res2 + res3, nil } If you want to write safe code you\u0026rsquo;ll have to write the boilerplate once and once again. And if you just write unsafe code, it\u0026rsquo;s way cleaner and more elegant, and there is nothing in the language that stops you from doing that.\nA good language design should make writing safe code easier and unsafe code harder. At least there should be a syntax sugar to simplify this, since 90% of the time you just want to return the error.\ndefer is not Block Scoped Instead of\nfunc doSomething() { { conn1 := connect1() defer close1(conn1) } { conn2 := connect1() defer close2(conn2) } { conn3 := connect3() defer close3(conn3) } } you have to write\nfunc doSomething() { func () { conn1 := connect1() defer close1(conn1) }() func () { conn2 := connect1() defer close2(conn2) }() func () { conn3 := connect3() defer close3(conn3) }() } I don\u0026rsquo;t know why Go doesn\u0026rsquo;t make defer block scoped. It\u0026rsquo;s just so much more convenient and intuitive.\nGo has block scoped variables, why not defer? It\u0026rsquo;s really silly to have to wrap everything in a lambda function just to use defer.\nNo Tuple Type Go doesn\u0026rsquo;t have tuple type. It make multiple return a feature but leaves tuple out of the language. I have no ideas why. The multiple return actually just returns a tuple, but you can\u0026rsquo;t receive the tuple as a whole or pass it around.\nfunc foo() (int, string) { return 1, \u0026#34;hello\u0026#34; } func bar(i int, s string) { fmt.Println(i, s) } func main() { bar(foo()) // valid!? } Why would this work? It\u0026rsquo;s just so inconsistent. If you can\u0026rsquo;t receive a tuple as a whole, why can you pass it as a whole? It\u0026rsquo;s just so weird.\nNo Runtime Const Go has no way to ensure immutability. If you declare a global map or slice, you have no guarantee that it won\u0026rsquo;t be modified.\nToo Strict Compiler I think it is common for programmers to comment out some code for debugging purpose. But if you comment out all the lines that use an import, Go will complain that the import is unused. You have to delete the import line to make it work. And when you uncomment the code, you have to add the import line back. It\u0026rsquo;s just so annoying. It is also the same case for unused variables.\nShouldn\u0026rsquo;t this be linter\u0026rsquo;s job? Why would the compiler care about this?\nIncluding map as Built-in Data Type Golang did a terrible choice by making map a built-in data type. This causes all map related operations are done on the syntax level, one example is checking existence\nif _, ok := m[k]; ok { // ... } Since map is a built-in data type, the language designers decide not to define methods on it. Instead golang has to introduce this weird syntax to check existence. It also makes it impossible to map, filter or fold on a map. You have to write a for loop to do that.\nTo use a set, one has to define something like map[int]struct{}, which is just ugly.\nmap as a built-in data type also create additional difficulty when adding generics to the language.\n","permalink":"https://noahele.github.io/Blog/posts/annoying-stuff-in-go/","summary":"\u003cp\u003eIn this blog I want to complain about some annoying stuff in Go. I\u0026rsquo;m not saying that Go is bad, in fact I love Go for its simplicity and ease of use. It\u0026rsquo;s just that there are some designs in Go that ruin the experience for me.\u003c/p\u003e\n\u003ch3 id=\"ugly-error-handling\"\u003eUgly Error Handling\u003c/h3\u003e\n\u003cp\u003eI\u0026rsquo;ll put a disclaimer here that I\u0026rsquo;m not a fan of exceptions either. I think exceptions are a bad idea in general. But I think Go\u0026rsquo;s error handling is even worse. Go\u0026rsquo;s error handling actually encourage those who are lazy and punish those who want to write good code.\u003c/p\u003e","title":"Annoying Stuff in Go"},{"content":"Recently I\u0026rsquo;ve been playing with Elixir and found a interesting operator called Pipe, which is |\u0026gt;. Elixir makes use of it to pipe a function\u0026rsquo;s output to another function. It helps to write clean code like this:\n\u0026#34;hello world\u0026#34; |\u0026gt; String.upcase() |\u0026gt; String.split(\u0026#34; \u0026#34;) |\u0026gt; Enum.reverse() |\u0026gt; Enum.join(\u0026#34; \u0026#34;) # instead of Enum.join(Enum.reverse(String.split(String.upcase(\u0026#34;hello world\u0026#34;), \u0026#34; \u0026#34;)), \u0026#34; \u0026#34;) But then I found that pipeline operator is not so common in other languages I know like Java, JavaScript and Python. It took me some time to realize that its equivalent in OOP world is just chaining methods due to the implicit this parameter in object methods. For example, in JavaScript, we can write:\n\u0026#39;hello world\u0026#39;.toUpperCase().split(\u0026#39; \u0026#39;).reverse().join(\u0026#39; \u0026#39;); But in Python, the join method is on string instead of list type, so we have to write:\n# either tmp variable words = \u0026#39;hello world\u0026#39;.upper().split(\u0026#39; \u0026#39;).reverse() \u0026#39; \u0026#39;.join(words) # or brackets hell \u0026#39; \u0026#39;.join(\u0026#39;hello world\u0026#39;.upper().split(\u0026#39; \u0026#39;).reverse()) I do feel that Python has a bad design here. Though it has the full power of OOP, it move a lot of method to global level like len, enumerate, map, filter. It\u0026rsquo;s neither consistent nor elegant, making chaining methods, which are easy in other languages, somewhat hard in Python.\nIt also pollutes the global namespace. I think all Python developers have encountered the problem of naming a variable max and then find that the variable conflicts with max function, then rename the variable to max1, num_max or something else. It\u0026rsquo;s really annoying.\nA good language design that I love is Rust. Chaining methods is easy in Rust, and even max can be called in chaining style as well as function style. Due to its explicit self parameter, methods can be both instance methods and a normal function. So you can write:\nlet vec = vec![1, 2, 3]; // chaining enumerate() vec.iter().enumerate(); // chaining map() vec.iter().map(); // chaining len() vec.len(); // even max() can be called in chaining style let a = 1.max(2); // and you can still call it in function style let b = i32::max(1, 2); Python and JavaScript can also achieve similar effects. Python has a explicit self parameter, and JavaScript has call, apply and bind to change the implicit this. But they are not widely used. e.g.\nlst = [1, 2, 3] list.append(lst, 4) const arr = [1, 2, 3]; Array.prototype.push.call(arr, 4); ","permalink":"https://noahele.github.io/Blog/posts/thoughts-on-pipe-operator/","summary":"\u003cp\u003eRecently I\u0026rsquo;ve been playing with Elixir and found a interesting operator called Pipe, which is \u003ccode\u003e|\u0026gt;\u003c/code\u003e. Elixir makes use of it to pipe a function\u0026rsquo;s output to another function. It helps to write clean code like this:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-elixir\" data-lang=\"elixir\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;hello world\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eString\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eupcase() \u003cspan style=\"color:#f92672\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eString\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003esplit(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEnum\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ereverse() \u003cspan style=\"color:#f92672\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEnum\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ejoin(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# instead of\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eEnum\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ejoin(\u003cspan style=\"color:#a6e22e\"\u003eEnum\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ereverse(\u003cspan style=\"color:#a6e22e\"\u003eString\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003esplit(\u003cspan style=\"color:#a6e22e\"\u003eString\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eupcase(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;hello world\u0026#34;\u003c/span\u003e), \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)), \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBut then I found that pipeline operator is not so common in other languages I know like Java, JavaScript and Python. It took me some time to realize that its equivalent in OOP world is just chaining methods due to the implicit \u003ccode\u003ethis\u003c/code\u003e parameter in object methods. For example, in JavaScript, we can write:\u003c/p\u003e","title":"Thoughts on Pipe Operator"},{"content":"","permalink":"https://noahele.github.io/Blog/posts/javascript-related/","summary":"","title":"Javascript Related"},{"content":"Java The reason why record classes have accessor methods instead of public final attributes: make it possible to override accessor methods allow the record class to implement interfaces Lombok @Data generates constructor only if there is no explicitly written constructor @Data should not be used on Hibernate entities, as the generated equals and hashCode methods will cause problems when the entity is detached from the session. Spring @Autowired can be used on constructor, setter and field. Constructor injection is recommended. My preference is constructor injection \u0026gt; setter injection \u0026gt; field injection. And then utilize @RequiredArgsConstructor lombok annotation to generate constructor with required fields. By marking all required beans private final, it is automatically present in the constructor generated and thus injected. I think this is a more elegant way of injecting dependencies. Circular references is discouraged and they are prohibited by default. Possible Solutions: Modify the code base to remove circular references Add @Lazy annotation to constructor, so that the bean is not created until it is needed Use setter injection instead of constructor injection ","permalink":"https://noahele.github.io/Blog/posts/java-related/","summary":"\u003ch2 id=\"java\"\u003eJava\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThe reason why \u003ccode\u003erecord\u003c/code\u003e classes have accessor methods instead of public final attributes:\n\u003cul\u003e\n\u003cli\u003emake it possible to override accessor methods\u003c/li\u003e\n\u003cli\u003eallow the \u003ccode\u003erecord\u003c/code\u003e class to implement interfaces\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"lombok\"\u003eLombok\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@Data\u003c/code\u003e generates constructor only if there is no explicitly written constructor\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@Data\u003c/code\u003e should not be used on Hibernate entities, as the generated \u003ccode\u003eequals\u003c/code\u003e and \u003ccode\u003ehashCode\u003c/code\u003e methods will cause problems when the entity is detached from the session.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"spring\"\u003eSpring\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@Autowired\u003c/code\u003e can be used on constructor, setter and field. Constructor injection is recommended.\n\u003cul\u003e\n\u003cli\u003eMy preference is constructor injection \u0026gt; setter injection \u0026gt; field injection. And then utilize \u003ccode\u003e@RequiredArgsConstructor\u003c/code\u003e lombok annotation to generate constructor with required fields. By marking all required beans \u003ccode\u003eprivate final\u003c/code\u003e, it is automatically present in the constructor generated and thus injected. I think this is a more elegant way of injecting dependencies.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCircular references is discouraged and they are prohibited by default. Possible Solutions:\n\u003cul\u003e\n\u003cli\u003eModify the code base to remove circular references\u003c/li\u003e\n\u003cli\u003eAdd \u003ccode\u003e@Lazy\u003c/code\u003e annotation to constructor, so that the bean is not created until it is needed\u003c/li\u003e\n\u003cli\u003eUse setter injection instead of constructor injection\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Java Related"},{"content":"Revise about many graph-searching related algorithms.\nDFS: Depth First Search Search till the leaf vertex then choose another path.\nIt will find a path between two vertices and it\u0026rsquo;s guaranteed to do so, however it is not guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed Uses a stack data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the stack while the vertex is not empty pop a vertex out of the stack if the vertex is: the destination, then end search marked visited, then continue unvisited: mark it as visited add its unvisited neighbors to the stack BFS: Breadth First Search Search all neighbors of a vertex then move on next level.\nIt is guaranteed to find the shortest path.\nworks on graphs that are:\nconnected unweighted directed cyclic Uses a queue data structure to traverse all nodes in a graph.\nSteps of the algorithm:\npush the root vertex to the queue mark the vertex visited while the queue is not empty: pop a vertex from queue if the vertex is: the destination, then end search else: mark its unvisited neighbors as visited push said neighbors to the queue Uniform Cost Search an adaptation of breadth-first search to make it work on weighted graph\nworks on graphs that are:\nconnected weighted: no negative edges directed cyclic Dijkstra Algorithm This algorithm find the shortest path from a vertex to all other vertices\nUsing 2 data structures:\na priority queue of vertices lists of: shortest distance and preceding vertices in shortest path The steps of this algorithm are:\nSet up auxiliary data structures While the priority queue has unexplored vertices: Take the next vertex from the priority queue Follow its edges and update any distances Its time complexity depends on the data structures used.\nIf we are using a heap for the priority queue and two array, the time complexity is $$O((V + E)logV)$$\nThis algorithm works on graphs that are:\ndirected weighted: only guaranteed to be correct when there are no negative edges Floyd-Warshall Algorithm for (i = 1; i \u0026lt;= n; i++) { for (j = 1; j \u0026lt;= n; j++) { if (e[i][j] \u0026gt; e[i][1] + e[1][j]) { e[i][j] = e[i][1] + e[1][j]; } } } For every intermediate vertex check if there is a shorter path from start to end point through the intermediate.\n","permalink":"https://noahele.github.io/Blog/posts/graph-search-algorithms/","summary":"\u003cp\u003eRevise about many graph-searching related algorithms.\u003c/p\u003e\n\u003ch2 id=\"dfs-depth-first-search\"\u003eDFS: Depth First Search\u003c/h2\u003e\n\u003cp\u003eSearch till the leaf vertex then choose another path.\u003c/p\u003e\n\u003cp\u003eIt will find a path between two vertices and it\u0026rsquo;s \u003cem\u003eguaranteed\u003c/em\u003e to do so, however it is \u003cem\u003enot guaranteed\u003c/em\u003e to find the shortest path.\u003c/p\u003e\n\u003cp\u003eworks on graphs that are:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003econnected\u003c/li\u003e\n\u003cli\u003eunweighted\u003c/li\u003e\n\u003cli\u003edirected\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eUses a stack data structure to traverse all nodes in a graph.\u003c/p\u003e\n\u003cp\u003eSteps of the algorithm:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003epush the root vertex to the stack\u003c/li\u003e\n\u003cli\u003ewhile the vertex is not empty\n\u003col\u003e\n\u003cli\u003epop a vertex out of the stack\u003c/li\u003e\n\u003cli\u003eif the vertex is:\n\u003col\u003e\n\u003cli\u003ethe destination, then end search\u003c/li\u003e\n\u003cli\u003emarked visited, then \u003ccode\u003econtinue\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eunvisited:\n\u003col\u003e\n\u003cli\u003emark it as visited\u003c/li\u003e\n\u003cli\u003eadd its unvisited neighbors to the stack\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"bfs-breadth-first-search\"\u003eBFS: Breadth First Search\u003c/h2\u003e\n\u003cp\u003eSearch all neighbors of a vertex then move on next level.\u003c/p\u003e","title":"Graph Search Algorithms"}]